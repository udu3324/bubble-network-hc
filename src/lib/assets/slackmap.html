<!-- visualizer by rowan -->
<!DOCTYPE html>
<html>

<head>
    <title>Slack Map</title>
    <style>
        canvas {
            outline: solid white 1px;
            margin: 0px;
        }

        * {
            margin: 0px;
        }

        body {
            background-color: rgb(2, 31, 46);
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <br>
    <div id="d"></div>
    <button onclick="reset()">Reset Space</button>

    <script> /* Stuff for danny */
        function resizeCanvas(width, height) {
            canvas.width = width;
            canvas.height = heightt;
        }

        function focusUser(slackId) {
            let i = slackIds.indexOf(slackId);
            king = i;
        }

        var mOffsetX = 0;
        var mOffsetY = 0;

        const websiteMode = false; // turn on when using server data, off when using random data (need to call gen() function for website)
    </script>
    <script> // RESIVE CANVAS HERE
        var canvas = document.getElementById("c");
        canvas.width = 750; // default width and height
        canvas.height = 750;




        var ctx = canvas.getContext('2d');

        var centerX = canvas.width / 2;
        var centerY = canvas.height / 2;

        var cameraX = 0;
        var cameraY = 0;

        var cameraZoom = 0.05; // higher = zoomed in
        var inputZoom = 12; // relative to 10

        function posX(x) {
            return (x - cameraX) * cameraZoom + centerX;
        }
        function posY(y) {
            return (y - cameraY) * cameraZoom + centerY;
        }




    </script>
    <script>


        
        class Vector2 {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
        }
        class Node { // id correlates to id in the list of peoples
            constructor(slackId, connections, id, connectionStrength) {
                this.user = slackId; // SLACK ID
                this.id = id; // ID IN THE ARRAY
                this.connections = connections; // Array of slackIds that they know
                this.connectionStrength = connectionStrength;
                this.connectionDisplay = []; // display only if your id is less
                this.connectionIds = [];
                this.pos = new Vector2(0, 0); // position
                this.rad = 25;

                while (true) { // find a random position for the node to be
                    let dir = Math.random() * Math.PI * 2;
                    let r = Math.random() * maxPos;
                    let x = Math.cos(dir) * r;
                    let y = Math.sin(dir) * r;
                    this.pos.x = x;
                    this.pos.y = y;
                    let breaker = true;
                    for (let i = 0; i < nodes.length; i++) {
                        let temp = nodes[i];
                        if (Math.sqrt(Math.pow(temp.pos.x - this.pos.x, 2) + Math.pow(temp.pos.y - this.pos.y, 2)) <= (this.rad + temp.rad) * 2) {
                            breaker = false;

                        }
                    }

                    if (breaker) { // NOT WORKING
                        //alert(id)
                        break;
                    }
                }

                this.startX = this.pos.x;
                this.startY = this.pos.y;



                this.color = "rgb(" + Math.random() * 200 + 55 + "," + Math.random() * 200 + 55 + "," + Math.random() * 200 + 55 + ")"; // random color

                this.touched = false;

                this.circleTouched = false; // is in kingcircle and is hovered over (king included)

                this.connectionLines = [];

                this.fade = 1; // smoothnessss
                this.lineNatural = 0.15;
                this.lineFade = this.lineNatural;

                this.displayName = masterData[this.id].username;

                this.img = null; // only load it once
                this.imgReady = false;


            }
            generateConnections() {
                for (let i = 0; i < this.connections.length; i++) {
                    let partnerIndex = slackIds.indexOf(this.connections[i])
                    this.connectionIds.push(partnerIndex);
                    let connection = new Connection(this, nodes[partnerIndex], this.connectionStrength[i]);
                    this.connectionLines.push(connection);
                    if (partnerIndex > this.id) {
                        this.connectionDisplay.push(connection);
                    }
                }

            }
            renderConnections() {
                let dx = 0;
                let dy = 0;
                if (!this.touched && taken != null) {
                    this.lineFade += (0 - this.lineFade) / 5;
                } else if (!this.touched) {
                    this.lineFade += (this.lineNatural - this.lineFade) / 16;
                } else {
                    this.lineFade += (.7 - this.lineFade) / 4;
                }
                if (king == this.id) {
                    this.lineFade = .2
                }
                // commented if statements check if connection is out of bounds
                //if (posX(this.pos.x) >= 0 - this.rad * cameraZoom && posX(this.pos.x) <= canvas.width * 1.25 + this.rad * cameraZoom) {
                //  if (posY(this.pos.y) >= 0 - this.rad * cameraZoom && posY(this.pos.y) <= canvas.height * 1.25 + this.rad * cameraZoom) {
                if (this.inRange()) {
                    ctx.globalAlpha = this.lineFade;
                    if (this.lineFade > 0.01) {
                        if (this.inZoom() || king == this.id) { // zooming out prioritizes people with larger connections

                            if (king == this.id || (this.touched && king == null)) {
                                for (let i = 0; i < this.connectionLines.length; i++) { // show all connections yipee
                                    this.connectionLines[i].display(this.color, (this.touched || king == this.id));
                                }
                            } else {
                                for (let i = 0; i < this.connectionDisplay.length; i++) { // only show connections that you prioritize (the code does)
                                    this.connectionDisplay[i].display(this.color, (this.touched || king == this.id));
                                }
                            }

                        }



                    }

                    ctx.globalAlpha = 1;
                }

            }
            display() {
                // move towards / away the king
                if (king != null && king != this.id) {
                    let target = nodes[king];
                    let targetX = target.pos.x;
                    let targetY = target.pos.y;
                    let dir = Math.atan((this.pos.x - targetX) / (this.pos.y - targetY));
                    dir = Math.atan2((this.pos.y - targetY), (this.pos.x - targetX))
                    let dist = Math.sqrt(Math.pow((this.pos.y - targetY), 2) + Math.pow((this.pos.x - targetX), 2));
                    if (this.connectionIds.includes(king)) { // move to
                        this.showName()
                    } else { // move away


                        this.pos.x += Math.cos(dir) * 10000 / dist * (1 + kingCircle.length / 10);
                        this.pos.y += Math.sin(dir) * 10000 / dist * (1 + kingCircle.length / 10);
                    }
                } else if (king == this.id) {
                    this.showName()
                } else { // no king selected, return to init pos
                    this.pos.x += (this.startX - this.pos.x) / 10;
                    this.pos.y += (this.startY - this.pos.y) / 10;
                }




                //alert("h")
                if (!this.touched && taken != null && king != this.id) {
                    if (this.connections.includes(slackIds[taken])) { // related to taken
                        this.fade += (1 - this.fade) / 4
                    } else {
                        if (this.fade > 0.25) this.fade += (0.01 - this.fade) / 8;
                    }

                } else {
                    this.fade += (1 - this.fade) / 4;

                }
                if (this.touched) {
                    this.showName()
                }
                ctx.globalAlpha = this.fade;


                // draw outline
                circ(this.pos.x, this.pos.y, this.rad * 1.1, "white")

                // draw circle

                circ(this.pos.x, this.pos.y, this.rad, this.color);
                ctx.globalAlpha = 1;


                // draw info box if im touched
                this.touch();
                if (this.circleTouched) {
                    //this.drawInfoBox();
                }


            }
            inRange() {
                if (king == this.id) {
                    return true;
                }

                if (posX(this.pos.x) <= canvas.width + this.rad * cameraZoom * 4 && posX(this.pos.x) >= 0 - this.rad * cameraZoom * 4) {
                    if (posY(this.pos.y) <= canvas.height + this.rad * cameraZoom * 4 && posY(this.pos.y) >= 0 - this.rad * cameraZoom * 4) {
                        return true;
                    }

                }

                return false;
            }
            inZoom() { // zooming out prioritizes nodes w/ larger connections
                return Math.pow(this.connectionLines.length, 2) > 150 / cameraZoom
            }
            showName() {
                // Show username
                let size = this.displayName.length;
                let fontSize = 15;
                ctx.font = cameraZoom * fontSize + "px monospace";
                ctx.fillStyle = "white"

                ctx.fillText(this.displayName, posX(this.pos.x - size * fontSize / 3), posY(this.pos.y + this.rad * 2))
            }
            touch() {
                let xp = posX(this.pos.x);
                let yp = posY(this.pos.y);

                this.touched = false;

                if (taken == null) { // nobody touched yet
                    let dist = Math.sqrt(Math.pow((xp - mouseX), 2) + Math.pow((yp - mouseY), 2))
                    if (dist <= this.rad * cameraZoom) {
                        taken = this.id;
                        this.touched = true;
                    }
                }

                if (king == null && this.touched && mouseDown && !mouseMoving) {
                    king = this.id;
                }

                this.circleTouched = false;
                // when in king mode hovering and stuff you know the drill
                if (king == this.id || (king != null && nodes[king].connectionIds.includes(this.id))) {
                    let dist = Math.sqrt(Math.pow((xp - mouseX), 2) + Math.pow((yp - mouseY), 2))
                    if (dist <= this.rad * cameraZoom) {
                        this.circleTouched = true;
                        //alert("wow")
                    }
                }


            }

            assignShell(shell) {
                this.shell = shell;
            }

            approachShell() {

                let angle = this.shell.angles[this.shell.children.indexOf(this)]
                let radius = this.shell.radius;
                let centerX = nodes[king].pos.x;
                let centerY = nodes[king].pos.y;

                let targetX = Math.cos(angle) * radius + centerX;
                let targetY = Math.sin(angle) * radius + centerY;

                let speed = (14 + this.shell.children.length / 3)

                this.pos.x += (targetX - this.pos.x) / speed;
                this.pos.y += (targetY - this.pos.y) / speed;

            }


            drawInfoBox() {

                // image handling
                if (this.img == null) { // need to load the image
                    this.img = new Image();
                    this.img.src = masterData[this.id].profile_picture;

                    this.img.onload = () => {
                        this.imgReady = true;
                    }


                }

                // draw box thingy ma boo
                ctx.font = "25px Courier New"
                let width = ctx.measureText("M").width;
                let nameWidth = width * this.displayName.length;
                //console.log(nameWidth)
                nameWidth -= 90;
                if (nameWidth < 0) {
                    nameWidth = 0;
                }

                let nameplateWidth = 200 + nameWidth * 1.25;

                let offset = 5;

                // loading text
                ctx.fillStyle = "white"
                ctx.font = "8px monospace"

                ctx.fillStyle = "rgb(10,16,26)"
                ctx.globalAlpha = 0.5;
                ctx.roundRect(mouseX + offset, mouseY - 100 - offset, nameplateWidth, 100, 5);
                ctx.fill()
                ctx.globalAlpha = 1.0;


                if (this.imgReady) { // draw image
                    ctx.drawImage(this.img, mouseX + 5 + offset, mouseY - offset - 95, 90, 90)
                }

                ctx.fillStyle = "white"
                ctx.font = "25px Courier New"
                ctx.fillText(this.displayName, mouseX + offset + 105, mouseY - offset - 45)

                ctx.font = "8px monospace"

                ctx.fillText("ID: " + this.user, mouseX + offset + 102, mouseY - offset - 10)

            }
        }

        class Connection { // MAKE A FEATURE TO WHEN IF NOT FOCUSED AND NOT KING THEN IF YOUR ID IS GREATER THAN ANOTHER DON'T RENDER YOUR CONNECTIONS BC OTHER ID WILL
            constructor(user1, user2, strength) {
                this.user1 = user1;
                this.user2 = user2;
                this.strength = 8;

            }
            display(color, doShadow) {
                //ctx.globalAlpha -= 0.1;
                if (doShadow) {
                    ctx.strokeStyle = "white";
                    ctx.beginPath();
                    ctx.lineWidth = this.strength * cameraZoom * 1.2;
                    ctx.moveTo(posX(this.user1.pos.x), posY(this.user1.pos.y));
                    ctx.lineTo(posX(this.user2.pos.x), posY(this.user2.pos.y));
                    ctx.stroke();
                }
                ctx.strokeStyle = color;
                ctx.beginPath();
                ctx.lineWidth = this.strength * cameraZoom;
                ctx.moveTo(posX(this.user1.pos.x), posY(this.user1.pos.y));
                ctx.lineTo(posX(this.user2.pos.x), posY(this.user2.pos.y));
                //ctx.lineTo(0,0)
                ctx.stroke();
                //ctx.globalAlpha = 1
            }
        }

        class Shell { // centerNode = actual king node, shell# 1-max count, radius = rad increasess, initcount = how many on first shell
            constructor(centerNode, shellNumber, initRadius, initCount) {
                this.centerNode = centerNode;
                this.shellNumber = shellNumber;
                this.radius = initRadius * shellNumber;
                this.count = initCount * shellNumber;

                this.x = centerNode.pos.x;
                this.y = centerNode.pos.y;

                this.children = []; // nodes belonging (ids)
                this.angles = []; // node angles
            }

            display() {
                ctx.strokeStyle = "white";
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = cameraZoom * 2;

                ctx.beginPath();
                ctx.arc(posX(this.x), posY(this.y), this.radius * cameraZoom, 0, 2 * Math.PI)
                ctx.stroke();
            }

            createAngles() { // after children are assigned
                let angle = Math.PI * 2 * Math.random();
                let d = Math.PI * 2 / this.children.length;
                for (let i = 0; i < this.children.length; i++) {
                    angle += d;
                    this.angles.push(angle);
                }
            }
        }


    </script>
    <script>

        var mapLoaded = false;

        var prevCamX = null;
        var prevCamY = null;

        // random names and images for testing
        var names = ["Amigo", "Friend", "Lonely", "Hacker"]
        var images = []; // contains urls
        images.push("https://images.pexels.com/photos/33713697/pexels-photo-33713697.jpeg");
        images.push("https://images.pexels.com/photos/35175266/pexels-photo-35175266.jpeg")
        images.push("https://images.pexels.com/photos/19829670/pexels-photo-19829670.jpeg");
        images.push("https://images.pexels.com/photos/35201958/pexels-photo-35201958.jpeg");
        images.push("https://images.pexels.com/photos/35109039/pexels-photo-35109039.jpeg");

        let masterArray = [];

        let masterData = []; // {slackid, username, profile} username = display name

        // HANDLE SLACK DATA
        var nodes = []; // one node for every user
        var slackIds = [];
        var slackConnections = [];
        var slackConnectionStrengths = []; // randomly generated

        function randomSlackUser() {
            let id = Math.random() + "";
            masterArray.push({ "slack_id": id, "id_list": [], "id_list_special": null });
            let myId = masterArray.length - 1;
            let usedFriends = [];
            for (let i = 0; i < 20; i++) {
                let randomFriend = Math.floor(Math.random() * masterArray.length);

                if (!usedFriends.includes(randomFriend)) {
                    masterArray[randomFriend].id_list.push(id);
                    masterArray[myId].id_list.push(masterArray[randomFriend].slack_id)
                }
                usedFriends.push(randomFriend);
            }
            // create random username

            masterData.push({ "slack_id": id, "username": names[Math.floor(Math.random() * names.length)], "profile_picture": images[Math.floor(Math.random() * images.length)] });


        }

        // ADD TO WHERE THE REDUCE CONNECTIONS WHEN ZOOMED OUT INCREASES CUT WHEN THERES MORE CONNECTIONS AVG
        if (!websiteMode) {
            for (let i = 0; i < 1000; i++) {
                randomSlackUser();
            }
            gen();
        }




        // OVERRIDE RANDOMNESS BY CALLING FOOBAR FUNCTIONS

        /*
        masterArray = foobar1();
        masterData = foobar3();
        */


        var maxPos = 4000;


        function gen() {
            // IF ON WEBSITE MODE, TAKE DATA FROM THE SERVER
            if (websiteMode) {
                masterArray = foobar1();
                masterData = foobar3();
            }




            // DERIVE IDS, CONNECTIONS FROM MASTER
            maxPos = 2000 + masterArray.length * 8
            for (let i = 0; i < masterArray.length; i++) {
                slackIds.push(masterArray[i].slack_id);
                slackConnections.push(masterArray[i].id_list);
            }


            // Eleminate any ids in connections that don't exist
            for (let i = 0; i < slackConnections.length; i++) {
                let nodeConnections = slackConnections[i];
                for (let j = nodeConnections.length - 1; j >= 0; j--) {
                    if (!slackIds.includes(nodeConnections[j]) || nodeConnections[j] == slackIds[i]) {
                        nodeConnections.splice(j, 1);
                    }
                }
                slackConnections[i] = nodeConnections;

                // Create randomly generated strengths for each connection

                let randomStrengths = [];
                for (let x = 0; x < nodeConnections.length; x++) {
                    randomStrengths.push(Math.ceil(Math.random() * 100));
                }
                slackConnectionStrengths.push(randomStrengths)


                // constructor(slackId, connections, id, connectionStrength)
                nodes.push(new Node(slackIds[i], slackConnections[i], i, slackConnectionStrengths[i]))
            }


            // generate connections for each node (visual)
            for (let i = 0; i < nodes.length; i++) {
                nodes[i].generateConnections()
            }


            mapLoaded = true;
        }








        // for smoothness
        var targetX = 0;
        var targetY = 0;
        var cameraEase = 10;

        // for hovering
        var taken = null; // will be set to id of node getting touched innapropriately

        // KINGNODE -> NODE THAT ENTIRE PROGRAM REVOLVES AROUND
        var king = null;
        var kingCircle = []; // people related to the king (ids)
        var kingStrengths = [];
        var prevKing = null;

        var kingShells = []; // shells to hold the nodes

        var zoomToKing = false; // when new focus put camera there

        // shell constants
        const _shellInitCount = 3;
        const _shellInitRadius = 200;




        var ticker = 0;
        function tick() {
            ticker += 0.2;
            

            if (!mapLoaded) {
                return;
            }


            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgb(2, 31, 46)"
            ctx.fillStyle = "##0f172b"
            ctx.fillRect(0, 0, canvas.width, canvas.height)

            // Update positional constants
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;

            cameraZoom += ds;
            ds *= df;

            if (cameraZoom < 0.01) { // max zoom out
                cameraZoom = 0.01;
                ds = 0;
            }
            if (cameraZoom > 10) { // max zoom in
                cameraZoom = 10;
                ds = 0;
            }
            //cameraZoom = Math.sin(tick) + 1;

            if (panOriginX != null) {
                zoomToKing = false;
                if (prevCamX == null) {
                    prevCamX = cameraX;
                    prevCamY = cameraY;
                }
                //cameraX = prevCamX - (panX - panOriginX)/cameraZoom;
                //cameraY = prevCamY - (panY - panOriginY)/cameraZoom;
                targetX = (prevCamX - (panX - panOriginX) / cameraZoom);
                targetY = (prevCamY - (panY - panOriginY) / cameraZoom)
                let dx = targetX - cameraX;
                let dy = targetY - cameraY;

                cameraX += dx / cameraEase;
                cameraY += dy / cameraEase;
            } else {
                if (prevCamX != null) {
                    prevCamX = null;
                }

                let dx = targetX - cameraX;
                let dy = targetY - cameraY;

                cameraX += dx / cameraEase;
                cameraY += dy / cameraEase;
                prevCamX = cameraX;
                prevCamY = cameraY;
            }

            if (zoomToKing) {
                cameraZoom += (0.2 - cameraZoom) / 30
                let tX = nodes[king].pos.x;
                let tY = nodes[king].pos.y;

                cameraX += (tX - cameraX) / 10;
                cameraY += (tY - cameraY) / 10;
                targetX = cameraX;
                targetY = cameraY;
            }

            //document.getElementById("d").innerHTML = panX + "," + panY;

            // if there is a king node, create the king circle, instant update after change
            if (king != prevKing) {
                prevKing = king;
                if (king != null) {
                    zoomToKing = true;
                    assembleKing()
                }
            }

            if (king != null) { // display shells and bring closer to king
                displayShells();
                surroundNodes();
            }

            // display the nodes

            displayNodes();




            mouseMoving = false;
        }

        function displayShells() {
            for (let i = 0; i < kingShells.length; i++) {
                kingShells[i].display();
            }
            //alert(kingShells.length)
        }

        function surroundNodes() {
            for (let i = 0; i < kingCircle.length; i++) {
                nodes[kingCircle[i]].approachShell()
            }
        }


        function circ(x, y, r, c) {
            ctx.fillStyle = c;
            ctx.beginPath();
            ctx.arc(posX(x), posY(y), r * cameraZoom, 0, 2 * Math.PI);
            ctx.fill();
            //alert(c)
        }

        function displayNodes() {
            //alert("h")
            taken = null;
            let circle = null;
            if (king != null) {
                taken = king;
            }
            for (let i = 0; i < nodes.length; i++) {
                nodes[i].touch();
                if (nodes[i].circleTouched) {
                    circle = i;
                }
            }
            for (let i = 0; i < nodes.length; i++) {
                nodes[i].renderConnections();
            }
            for (let i = 0; i < nodes.length; i++) {
                let temp = nodes[i];
                temp.display()
            }

            if (circle != null) {
                nodes[circle].drawInfoBox();
            }
        }

        function assembleKing() {
            // king circle = connections to the king
            var kingNode = nodes[king]
            kingCircle = kingNode.connectionIds;
            kingStrengths = kingNode.connectionStrength;

            // sort the powers array while keeping kingCircle array in same order

            for (let a = 0; a < kingStrengths.length; a++) {
                for (let i = 0; i < kingStrengths.length - a; i++) {
                    if (kingStrengths[i] < kingStrengths[i + 1]) {
                        let temp = kingStrengths[i];
                        kingStrengths[i] = kingStrengths[i + 1];
                        kingStrengths[i + 1] = temp;

                        temp = kingCircle[i];
                        kingCircle[i] = kingCircle[i + 1];
                        kingCircle[i + 1] = temp;
                    }
                }
            }
            // CREATE THE SHELLS


            // find needed # of shells
            kingShells = [];
            let numShells = 0;
            let slotsNeeded = kingCircle.length;
            while (true) {
                numShells++;
                slotsNeeded -= (numShells) * _shellInitCount;
                if (slotsNeeded <= 0) {
                    break;
                }
            }

            // create shells + assign nodes

            let overallIndex = 0;

            for (let i = 0; i < numShells; i++) {
                kingShells.push(new Shell(kingNode, i + 1, _shellInitRadius, _shellInitCount))
                let currentShell = kingShells[i];
                let nodesToAdd = (i + 1) * _shellInitCount;
                let x = 0;
                for (x = 0; x < nodesToAdd; x++) {
                    if (x + overallIndex >= kingCircle.length) {
                        break; // will also be end of overall for loop
                    }
                    let currentNode = nodes[kingCircle[x + overallIndex]]
                    currentShell.children.push(currentNode);
                    currentNode.assignShell(currentShell);


                }
                overallIndex += x;

                currentShell.createAngles();

            }


        }


        function reset() {
            king = null;
            zoomToKing = false;
        }

        // might be better to render shapes at center of shape instead of corner as well



    </script>
    <!-- Inputs -->
    <script>
        var userScroll = 0;
        var ds = 0; // velocity of scroll
        var df = 0.8; // friction for smoothness
        var cX = 0;
        var cY = 0;
        var scrolling = false
        canvas.addEventListener("wheel", function (e) {
            e.preventDefault();
            zoomToKing = false;
            if (scrolling == false) {
                scrolling = true;
                cX = mouseX;
                cY = mouseY;
                //zoomToKing = false;
            }
            if (event.deltaY > 0) { // zoom out
                //cameraZoom -= cameraZoom/10;
                ds = 0 - cameraZoom / 10;
            } else if (event.deltaY < 0) { // zoom in
                //cameraZoom += cameraZoom/10;
                ds = cameraZoom / 10;
            }




        });
        canvas.addEventListener('contextmenu', event => event.preventDefault());
        var panOriginX = null;
        var panOriginY = null;
        var panX = 0;
        var panY = 0;

        var mouseX = 0;
        var mouseY = 0;

        var mouseDown = false;
        var mouseMoving = false;

        canvas.addEventListener('mousedown', function (e) {
            if (e.button == 2) { // right click
                if (panOriginX == null) {
                    panOriginX = e.clientX - mOffsetX;
                    panOriginY = e.clientY- mOffsetY;
                }
                panX = e.clientX - mOffsetX;
                panY = e.clientY;

                zoomToKing = false;

                mouseDown = false;

                document.body.style.cursor = "grab";
            } else {
                mouseDown = true;
            }

        })
        document.addEventListener("mousemove", function (e) {
            if (panOriginX != null) {
                panX = e.clientX - mOffsetX;
                panY = e.clientY - mOffsetY;

                zoomToKing = false;
            }
            mouseX = e.clientX - mOffsetX;
            mouseY = e.clientY- mOffsetY;

            mouseMoving = true;
        })
        document.addEventListener('mouseup', function (e) {
            if (e.button == 2) { // right click
                panOriginX = null;
                document.body.style.cursor = "auto";
            } else {
                mouseDown = false;
            }


        })
    </script>
    <script>
        function loop() {
            tick();
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    </script>
</body>

</html>